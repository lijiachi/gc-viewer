> 赋值运算符=

分基本类型数据和引用类型数据:\
基本类型如:byte char boolean等:\
byte a = 10;//将10存放到a中\
byte b = a;//将a中的值拷贝一份放入b中\
引用类型如:Integer Double Boolean等:\
Integer a = 10;//为10创建一个引用a\
Integer b = a;//不会创建新的对象\
> 比较运算符==

基本类型的比较是内存中的值:
int a = 10;
int b = 10;
a == b //true

引用类型比较是否为同一个对象(同一块内存)

String dog1 = new String("Tom");
String dog2 = new String("Tom"");
String dog3 = dog1;
dog1 == dog2 //false
dog1 == dog3 //true
>但请注意

dog1.equals(dog2)//true
equals就是专门在业务层比较两个对象值而不是内存的方法

>总结:基本类型拷贝数据用=即可，引用类型则需new一个新的对象或者自行利用深度拷贝工具
> 基本类型比较值用==即可，引用类型需用equals方法(除非想确定是否引用同一个对象)

> 以上总结为概念层，从底层字节码来看，对基本或引用类型使用=或==运算符时有固定的基本操作，不存在适用不适用这种业务层面的衡量维度

> 字节码层原理(选择性阅读)

// 赋值运算符在字节码层面只有两条单指令：
// 1. 基本类型：istore/lstore/fstore/dstore/Astore_＜n＞
//    动作：把操作数栈顶值按位复制到局部变量表 slot n，无类型信息保留。
// 2. 引用类型：astore + 对象句柄
//    动作：复制的是句柄（compressed oop 或 64-bit 未压缩地址），
//         目标变量与源变量指向同一 mark-word + klass-word 起始的堆区域。
// 因此“深/浅”语义完全由类型描述符决定，与运算符本身无关。

int  a = 1;
int  b = a;      // 复制 4 字节值，此后 a、b 在栈帧内各占独立 slot
User u1 = new User();
User u2 = u1;    // 复制 4/8 字节地址，栈帧内两个 slot 同值 → 同一对象

// 关系运算符 == 在 HotSpot 模板解释器里对应
// if_icmpEQ/if_acmpEQ 两条条件跳转字节码：
// 1. 基本路径：弹出两个栈顶字，按位比较，ZF=1 则跳转。
// 2. 引用路径：弹出两个 oop，比较前已隐过 NULL 检查，实际就是
//    cmp   reg, reg   （32 位）或
//    cmp   reg, reg   （64 位压缩 oop 解码后）
//    结果只反映地址相等性，不触碰对象头任何字段。
// 由此推出：String s1 = new String("x"); String s2 = new String("x");
// s1 == s2 为 false 是 CPU 层面地址不相等，与 String 内容无关。

// 缓存池现象解释（IntegerCache）：
// 编译期 Integer x = 127; 被解糖为
// Integer x = Integer.valueOf(127);
// valueOf 内部数组 IntegerCache.cache[] 预加载 [-128,127] 的 Integer 对象，
// 因此同字面量取到同一全局数组元素，== 返回 true；超出范围则每次新建 Heap 对象。

// String 常量池现象：
// 类文件常量池 #utf8 项在类加载时由 resolve_utf8 创建 intern String，
// 后续相同字面量被 ldc 指令直接指向同一份 instance，因此
// String a = "abc"; String b = "abc"; 在运行时常量池解析后地址一致。
